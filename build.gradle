import com.badlogic.gdx.jnigen.BuildConfig
import com.badlogic.gdx.jnigen.gradle.JnigenExtension

import java.nio.file.Paths

// Add buildscript dependency
buildscript {
    dependencies {
        classpath "com.badlogicgames.gdx:gdx-jnigen-gradle:2.3.1"
    }
}

plugins {
    id 'java-library'
}

targetCompatibility = JavaVersion.VERSION_11
sourceCompatibility = JavaVersion.VERSION_11

sourceSets {
    main {
        resources {
            srcDirs "src/main/resources", "tmp/Debug/", "/tmp/native-deps/april-tags/Debug"
        }
    }
}

// Apply jnigen plugin
apply plugin: "com.badlogicgames.gdx.gdx-jnigen"
jnigen {
    sharedLibName = "april_tags"
    libsDir = "build/jnigen-lib"
    subProjectDir = ""
    jniDir = "build/jnigen-jni"

    all {
        cFlags += " "
        cIncludes += "native-deps"
        cIncludes += "jni"
    }
}

void delDir(File dir) {
    for(File f : dir.listFiles()) {
        if(f.isDirectory()) delDir(f);
        else f.delete();
    }

    if(!dir.deleteDir()) throw new RuntimeException("Failed to delete ${dir.absolutePath}");
}

task buildJniLib {
    dependsOn tasks.jnigen
    doLast {
        def build = file("${projectDir}/tmp")

        if(build.exists()) delDir(build)

        if(!build.mkdirs()) throw new RuntimeException("Failed to create/utilize tmp")

        def pcs = new ProcessBuilder()
                .directory(build)
                .command("cmake", "${projectDir}", "-DBUILD_SHARED_LIBS=OFF", "-DCMAKE_BUILD_TYPE=Release")
                .redirectOutput(ProcessBuilder.Redirect.to(file("${build}/output.log")))
                .redirectError(ProcessBuilder.Redirect.to(file("${build}/error.log")))
                .start();

        int exit = pcs.waitFor();

        if(exit != 0) throw new RuntimeException("Failed to run cmake");

        pcs = new ProcessBuilder()
                .directory(build)
                .command("cmake", "--build", ".")
                .redirectOutput(ProcessBuilder.Redirect.appendTo(file("${build}/output.log")))
                .redirectError(ProcessBuilder.Redirect.appendTo(file("${build}/error.log")))
                .start();

        exit = pcs.waitFor();

        if(exit != 0) throw new RuntimeException("Failed to build");
    }
}

task enforceLibDir {
    doLast {
        File libDir = file("jnigen-lib")
        logger.lifecycle("${libDir} exists: ${libDir.exists()}")
        if (libDir.exists() && !libDir.deleteDir()) throw new RuntimeException("Failed to make parent dir")
    }
}

tasks.jar.dependsOn(buildJniLib)

repositories {
    mavenCentral()
}

dependencies {
    testImplementation group: 'org.openpnp', name: 'opencv', version: '4.5.5-1'
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.9.1'
    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.9.1'

}

test {
    useJUnitPlatform()

    testLogging {
        events "standard_out", "standard_error"
        showExceptions = (true)
    }
}

task outputSources {
    doLast {
        def sourceDir = file("jni")

        def sourceFiles = new LinkedList<String>()
        for(File f : sourceDir.listFiles()) {
            if(f.name.endsWith(".cpp")) sourceFiles.add(f.absolutePath)
        }

        def sourceCmakeFile = file("cmake/sources.txt")
        sourceFiles = sourceFiles.collect {"\"${it.replaceAll("\\\\", "/")}\""}

        sourceCmakeFile.text = """list(APPEND JNI_CPP_SOURCES
    ${sourceFiles.join("\n    ")}
)"""
    }
}

tasks.jnigen {
    dependsOn tasks.enforceLibDir
    finalizedBy tasks.outputSources
}

task enforceJniDir {
    doLast {
        File libDir = file("jnigen-jni")
        logger.lifecycle("${libDir} exists: ${libDir.exists()}")
        if (libDir.exists() && !libDir.deleteDir()) throw new RuntimeException("Failed to make parent dir")
    }
}

tasks.jnigenBuild {
    dependsOn tasks.enforceJniDir
}

